%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{fdasrsf Documentation}
\date{Oct 22, 2020}
\release{2.1.7}
\author{J. Derek Tucker}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


A python package for functional data analysis using the square root
slope framework and curves using the square root velocity framework
which performs pair\sphinxhyphen{}wise and group\sphinxhyphen{}wise alignment as well as modeling
using functional component analysis and regression.


\chapter{Functional Alignment}
\label{\detokenize{time_warping:module-time_warping}}\label{\detokenize{time_warping:functional-alignment}}\label{\detokenize{time_warping::doc}}\index{module@\spxentry{module}!time\_warping@\spxentry{time\_warping}}\index{time\_warping@\spxentry{time\_warping}!module@\spxentry{module}}
Group\sphinxhyphen{}wise function alignment using SRSF framework and Dynamic Programming

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{align\_fPCA() (in module time\_warping)@\spxentry{align\_fPCA()}\spxextra{in module time\_warping}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.align_fPCA}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{time\_warping.}}\sphinxbfcode{\sphinxupquote{align\_fPCA}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{num\_comp}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{showplot}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{smoothdata}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{}
aligns a collection of functions while extracting principal components.
The functions are aligned to the principal components
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_comp}} \textendash{} number of fPCA components

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{showplot}} \textendash{} Shows plots of results using matplotlib (default = T)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth\_data}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Smooth the data using a box filter (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cores}} \textendash{} number of cores for parallel (default = \sphinxhyphen{}1 (all))

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions \sphinxhyphen{} numpy ndarray of shape (M,N) of N
functions with M samples

\item[{Return qn}] \leavevmode
aligned srvfs \sphinxhyphen{} similar structure to fn

\item[{Return q0}] \leavevmode
original srvf \sphinxhyphen{} similar structure to fn

\item[{Return mqn}] \leavevmode
srvf mean or median \sphinxhyphen{} vector of length M

\item[{Return gam}] \leavevmode
warping functions \sphinxhyphen{} similar structure to fn

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\item[{Return orig\_var}] \leavevmode
Original Variance of Functions

\item[{Return amp\_var}] \leavevmode
Amplitude Variance

\item[{Return phase\_var}] \leavevmode
Phase Variance

\end{description}\end{quote}

\end{fulllineitems}

\index{align\_fPLS() (in module time\_warping)@\spxentry{align\_fPLS()}\spxextra{in module time\_warping}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.align_fPLS}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{time\_warping.}}\sphinxbfcode{\sphinxupquote{align\_fPLS}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{g}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{comps}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{showplot}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{smoothdata}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{delta}\DUrole{o}{=}\DUrole{default_value}{0.01}}, \emph{\DUrole{n}{max\_itr}\DUrole{o}{=}\DUrole{default_value}{100}}}{}
This function aligns a collection of functions while performing
principal least squares
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{g}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{comps}} \textendash{} number of fPLS components

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{showplot}} \textendash{} Shows plots of results using matplotlib (default = T)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth\_data}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Smooth the data using a box filter (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delta}} \textendash{} gradient step size

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_itr}} \textendash{} maximum number of iterations

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return fn}] \leavevmode
aligned functions \sphinxhyphen{} numpy ndarray of shape (M,N) of N

\end{description}\end{quote}

functions with M samples
:return gn: aligned functions \sphinxhyphen{} numpy ndarray of shape (M,N) of N
functions with M samples
:return qfn: aligned srvfs \sphinxhyphen{} similar structure to fn
:return qgn: aligned srvfs \sphinxhyphen{} similar structure to fn
:return qf0: original srvf \sphinxhyphen{} similar structure to fn
:return qg0: original srvf \sphinxhyphen{} similar structure to fn
:return gam: warping functions \sphinxhyphen{} similar structure to fn
:return wqf: srsf principal weight functions
:return wqg: srsf principal weight functions
:return wf: srsf principal weight functions
:return wg: srsf principal weight functions
:return cost: cost function value

\end{fulllineitems}

\index{fdawarp (class in time\_warping)@\spxentry{fdawarp}\spxextra{class in time\_warping}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.fdawarp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{time\_warping.}}\sphinxbfcode{\sphinxupquote{fdawarp}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{time}}}{}
This class provides alignment methods for functional data using the SRVF framework

Usage:  obj = fdawarp(f,t)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} (M,N): matrix defining N functions of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} time vector of length M

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn}} \textendash{} aligned functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{qn}} \textendash{} aligned srvfs

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q0}} \textendash{} initial srvfs

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fmean}} \textendash{} function mean

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mqn}} \textendash{} mean srvf

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gam}} \textendash{} warping functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{psi}} \textendash{} srvf of warping functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stats}} \textendash{} alignment statistics

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{qun}} \textendash{} cost function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lambda}} \textendash{} lambda

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} \textendash{} optimization method

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamI}} \textendash{} inverse warping function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rsamps}} \textendash{} random samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fs}} \textendash{} random aligned functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gams}} \textendash{} random warping functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ft}} \textendash{} random warped functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{qs}} \textendash{} random aligned srvfs

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{type}} \textendash{} alignment type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mcmc}} \textendash{} mcmc output if bayesian

\end{itemize}

\end{description}\end{quote}

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  15\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{gauss\_model() (time\_warping.fdawarp method)@\spxentry{gauss\_model()}\spxextra{time\_warping.fdawarp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.fdawarp.gauss_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gauss\_model}}}{\emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{sort\_samples}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function models the functional data using a Gaussian model
extracted from the principal components of the srvfs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{integer}}) \textendash{} number of random samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sort\_samples}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} sort samples (default = T)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{joint\_gauss\_model() (time\_warping.fdawarp method)@\spxentry{joint\_gauss\_model()}\spxextra{time\_warping.fdawarp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.fdawarp.joint_gauss_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{joint\_gauss\_model}}}{\emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{3}}}{}
This function models the functional data using a joint Gaussian model
extracted from the principal components of the srsfs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{integer}}) \textendash{} number of random samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} (\sphinxstyleliteralemphasis{\sphinxupquote{integer}}) \textendash{} number of principal components (default = 3)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{multiple\_align\_functions() (time\_warping.fdawarp method)@\spxentry{multiple\_align\_functions()}\spxextra{time\_warping.fdawarp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.fdawarp.multiple_align_functions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{multiple\_align\_functions}}}{\emph{\DUrole{n}{mu}}, \emph{\DUrole{n}{omethod}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}DP\textquotesingle{}}}, \emph{\DUrole{n}{smoothdata}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{lam}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{}
This function aligns a collection of functions using the elastic square\sphinxhyphen{}root
slope (srsf) framework.
\begin{description}
\item[{Usage:  obj.multiple\_align\_functions(mu)}] \leavevmode
obj.multiple\_align\_functions(lambda)

\end{description}

obj.multiple\_align\_functions(lambda, …)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mu}} \textendash{} vector of function to align to

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omethod}} \textendash{} optimization method (DP, DP2, RBFGS) (default = DP)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smoothdata}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Smooth the data using a box filter (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} run in parallel (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} controls the elasticity (default = 0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cores}} \textendash{} number of cores for parallel (default = \sphinxhyphen{}1 (all))

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (time\_warping.fdawarp method)@\spxentry{plot()}\spxextra{time\_warping.fdawarp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.fdawarp.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{}{}
plot plot functional alignment results

Usage: obj.plot()

\end{fulllineitems}

\index{srsf\_align() (time\_warping.fdawarp method)@\spxentry{srsf\_align()}\spxextra{time\_warping.fdawarp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.fdawarp.srsf_align}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{srsf\_align}}}{\emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}mean\textquotesingle{}}}, \emph{\DUrole{n}{omethod}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}DP\textquotesingle{}}}, \emph{\DUrole{n}{smoothdata}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{lam}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{}
This function aligns a collection of functions using the elastic
square\sphinxhyphen{}root slope (srsf) framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} \textendash{} (string) warp calculate Karcher Mean or Median (options = “mean” or “median”) (default=”mean”)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omethod}} \textendash{} optimization method (DP, DP2, RBFGS) (default = DP)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smoothdata}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Smooth the data using a box filter (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} run in parallel (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} controls the elasticity (default = 0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cores}} \textendash{} number of cores for parallel (default = \sphinxhyphen{}1 (all))

\end{itemize}

\end{description}\end{quote}

Examples
\textgreater{}\textgreater{}\textgreater{} import tables
\textgreater{}\textgreater{}\textgreater{} fun=tables.open\_file(“../Data/simu\_data.h5”)
\textgreater{}\textgreater{}\textgreater{} f = fun.root.f{[}:{]}
\textgreater{}\textgreater{}\textgreater{} f = f.transpose()
\textgreater{}\textgreater{}\textgreater{} time = fun.root.time{[}:{]}
\textgreater{}\textgreater{}\textgreater{} obj = fs.fdawarp(f,time)
\textgreater{}\textgreater{}\textgreater{} obj.srsf\_align()

\end{fulllineitems}


\end{fulllineitems}

\index{normal() (in module time\_warping)@\spxentry{normal()}\spxextra{in module time\_warping}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.normal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{time\_warping.}}\sphinxbfcode{\sphinxupquote{normal}}}{\emph{\DUrole{n}{loc}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{scale}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{size}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Draw random samples from a normal (Gaussian) distribution.

The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently %
\begin{footnote}[2]\sphinxAtStartFootnote
P. R. Peebles Jr., “Central Limit Theorem” in “Probability,
Random Variables and Random Signal Principles”, 4th ed., 2001,
pp. 51, 51, 125.
%
\end{footnote}, is often called the bell curve because of
its characteristic shape (see the example below).

The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution \sphinxfootnotemark[2].

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{normal}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{loc}] \leavevmode{[}float or array\_like of floats{]}
Mean (“centre”) of the distribution.

\item[{scale}] \leavevmode{[}float or array\_like of floats{]}
Standard deviation (spread or “width”) of the distribution. Must be
non\sphinxhyphen{}negative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{loc}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(loc, scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized normal distribution.

\end{description}
\begin{description}
\item[{scipy.stats.norm}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.normal: which should be used for new code.

The probability density for the Gaussian distribution is
\begin{equation*}
\begin{split}p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },\end{split}
\end{equation*}
where \(\mu\) is the mean and \(\sigma\) the standard
deviation. The square of the standard deviation, \(\sigma^2\),
is called the variance.

The function has its peak at the mean, and its “spread” increases with
the standard deviation (the function reaches 0.607 times its maximum at
\(x + \sigma\) and \(x - \sigma\) \sphinxfootnotemark[2]).  This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.1} \PYG{c+c1}{\PYGZsh{} mean and standard deviation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Verify the mean and the variance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{mu} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.0  \PYGZsh{} may vary}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{ddof}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.1  \PYGZsh{} may vary}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}
\PYG{g+gp}{... }               \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Two\sphinxhyphen{}by\sphinxhyphen{}four array of samples from N(3, 6.25):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}4.49401501,  4.00950034, \PYGZhy{}1.81814867,  7.29718677],   \PYGZsh{} random}
\PYG{g+go}{       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{pairwise\_align\_bayes() (in module time\_warping)@\spxentry{pairwise\_align\_bayes()}\spxextra{in module time\_warping}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.pairwise_align_bayes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{time\_warping.}}\sphinxbfcode{\sphinxupquote{pairwise\_align\_bayes}}}{\emph{\DUrole{n}{f1i}}, \emph{\DUrole{n}{f2i}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{mcmcopts}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This function aligns two functions using Bayesian framework. It will align
f2 to f1. It is based on mapping warping functions to a hypersphere, and a
subsequent exponential mapping to a tangent space. In the tangent space,
the Z\sphinxhyphen{}mixture pCN algorithm is used to explore both local and global
structure in the posterior distribution.

The Z\sphinxhyphen{}mixture pCN algorithm uses a mixture distribution for the proposal
distribution, controlled by input parameter zpcn. The zpcn\$betas must be
between 0 and 1, and are the coefficients of the mixture components, with
larger coefficients corresponding to larger shifts in parameter space. The
zpcn{[}“probs”{]} give the probability of each shift size.
\begin{description}
\item[{Usage:  out = pairwise\_align\_bayes(f1i, f2i, time)}] \leavevmode
out = pairwise\_align\_bayes(f1i, f2i, time, mcmcopts)

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f1i}} \textendash{} vector defining M samples of function 1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f2i}} \textendash{} vector defining M samples of function 2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} time vector of length M

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mcmopts}} \textendash{} dict of mcmc parameters

\end{itemize}

\end{description}\end{quote}

default mcmc options:
tmp = \{“betas”:np.array({[}0.5,0.5,0.005,0.0001{]}),”probs”:np.array({[}0.1,0.1,0.7,0.1{]})\}
mcmcopts = \{“iter”:2*(10**4) ,”burnin”:np.minimum(5*(10**3),2*(10**4)//2),
\begin{quote}

“alpha0”:0.1, “beta0”:0.1,”zpcn”:tmp,”propvar”:1,
“initcoef”:np.repeat(0,20), “npoints”:200, “extrainfo”:True\}
\end{quote}

:rtype collection containing
:return f2\_warped: aligned f2
:return gamma: warping function
:return g\_coef: final g\_coef
:return psi: final psi
:return sigma1: final sigma

if extrainfo
:return accept: accept of psi samples
:return betas\_ind
:return logl: log likelihood
:return gamma\_mat: posterior gammas
:return gamma\_stats: posterior gamma stats
:return xdist: phase distance posterior
:return ydist: amplitude distance posterior)

\end{fulllineitems}

\index{rand() (in module time\_warping)@\spxentry{rand()}\spxextra{in module time\_warping}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{time_warping:time_warping.rand}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{time\_warping.}}\sphinxbfcode{\sphinxupquote{rand}}}{\emph{d0}, \emph{d1}, \emph{...}, \emph{dn}}{}
Random values in a given shape.

\begin{sphinxadmonition}{note}{Note:}
This is a convenience function for users porting code from Matlab,
and wraps \sphinxtitleref{random\_sample}. That function takes a
tuple to specify the size of the output, which is consistent with
other NumPy functions like \sphinxtitleref{numpy.zeros} and \sphinxtitleref{numpy.ones}.
\end{sphinxadmonition}

Create an array of the given shape and populate it with
random samples from a uniform distribution
over \sphinxcode{\sphinxupquote{{[}0, 1)}}.
\begin{description}
\item[{d0, d1, …, dn}] \leavevmode{[}int, optional{]}
The dimensions of the returned array, must be non\sphinxhyphen{}negative.
If no argument is given a single Python float is returned.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray, shape \sphinxcode{\sphinxupquote{(d0, d1, ..., dn)}}{]}
Random values.

\end{description}

random

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{array([[ 0.14022471,  0.96360618],  \PYGZsh{}random}
\PYG{g+go}{       [ 0.37601032,  0.25528411],  \PYGZsh{}random}
\PYG{g+go}{       [ 0.49313049,  0.94909878]]) \PYGZsh{}random}
\end{sphinxVerbatim}

\end{fulllineitems}



\chapter{Functional Principal Component Analysis}
\label{\detokenize{fPCA:module-fPCA}}\label{\detokenize{fPCA:functional-principal-component-analysis}}\label{\detokenize{fPCA::doc}}\index{module@\spxentry{module}!fPCA@\spxentry{fPCA}}\index{fPCA@\spxentry{fPCA}!module@\spxentry{module}}
Vertical and Horizontal Functional Principal Component Analysis using SRSF

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{fdahpca (class in fPCA)@\spxentry{fdahpca}\spxextra{class in fPCA}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdahpca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{fPCA.}}\sphinxbfcode{\sphinxupquote{fdahpca}}}{\emph{\DUrole{n}{fdawarp}}}{}
This class provides horizontal fPCA using the
SRVF framework

Usage:  obj = fdahpca(warp\_data)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warp\_data}} \textendash{} fdawarp class with alignment data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gam\_pca}} \textendash{} warping functions principal directions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{psi\_pca}} \textendash{} srvf principal directions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{latent}} \textendash{} latent values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{U}} \textendash{} eigenvectors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coef}} \textendash{} coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec}} \textendash{} shooting vectors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mu}} \textendash{} Karcher Mean

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau}} \textendash{} principal directions

\end{itemize}

\end{description}\end{quote}

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  15\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{calc\_fpca() (fPCA.fdahpca method)@\spxentry{calc\_fpca()}\spxextra{fPCA.fdahpca method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdahpca.calc_fpca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_fpca}}}{\emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{3}}}{}
This function calculates horizontal functional principal component analysis on aligned data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{no}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of components to extract (default = 3)

\item[{Return type}] \leavevmode
fdahpca object of numpy ndarray

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (fPCA.fdahpca method)@\spxentry{plot()}\spxextra{fPCA.fdahpca method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdahpca.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{}{}
plot plot elastic horizontal fPCA results

Usage: obj.plot()

\end{fulllineitems}


\end{fulllineitems}

\index{fdajpca (class in fPCA)@\spxentry{fdajpca}\spxextra{class in fPCA}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdajpca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{fPCA.}}\sphinxbfcode{\sphinxupquote{fdajpca}}}{\emph{\DUrole{n}{fdawarp}}}{}
This class provides joint fPCA using the
SRVF framework

Usage:  obj = fdajpca(warp\_data)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warp\_data}} \textendash{} fdawarp class with alignment data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q\_pca}} \textendash{} srvf principal directions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f\_pca}} \textendash{} f principal directions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{latent}} \textendash{} latent values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coef}} \textendash{} principal coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} point used for f(0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mqn}} \textendash{} mean srvf

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{U}} \textendash{} eigenvectors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mu\_psi}} \textendash{} mean psi

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mu\_g}} \textendash{} mean g

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{C}} \textendash{} scaling value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stds}} \textendash{} geodesic directions

\end{itemize}

\end{description}\end{quote}

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  18\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{calc\_fpca() (fPCA.fdajpca method)@\spxentry{calc\_fpca()}\spxextra{fPCA.fdajpca method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdajpca.calc_fpca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_fpca}}}{\emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{id}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This function calculates joint functional principal component analysis
on aligned data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of components to extract (default = 3)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} point to use for f(0) (default = midpoint)

\end{itemize}

\item[{Return type}] \leavevmode
fdajpca object of numpy ndarray

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (fPCA.fdajpca method)@\spxentry{plot()}\spxextra{fPCA.fdajpca method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdajpca.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{}{}
plot plot elastic vertical fPCA result

Usage: obj.plot()

\end{fulllineitems}


\end{fulllineitems}

\index{fdavpca (class in fPCA)@\spxentry{fdavpca}\spxextra{class in fPCA}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdavpca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{fPCA.}}\sphinxbfcode{\sphinxupquote{fdavpca}}}{\emph{\DUrole{n}{fdawarp}}}{}
This class provides vertical fPCA using the
SRVF framework

Usage:  obj = fdavpca(warp\_data)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warp\_data}} \textendash{} fdawarp class with alignment data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q\_pca}} \textendash{} srvf principal directions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f\_pca}} \textendash{} f principal directions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{latent}} \textendash{} latent values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coef}} \textendash{} principal coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} point used for f(0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mqn}} \textendash{} mean srvf

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{U}} \textendash{} eigenvectors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stds}} \textendash{} geodesic directions

\end{itemize}

\end{description}\end{quote}

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  15\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{calc\_fpca() (fPCA.fdavpca method)@\spxentry{calc\_fpca()}\spxextra{fPCA.fdavpca method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdavpca.calc_fpca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_fpca}}}{\emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{id}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This function calculates vertical functional principal component analysis
on aligned data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} number of components to extract (default = 3)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} point to use for f(0) (default = midpoint)

\end{itemize}

\item[{Return type}] \leavevmode
fdavpca object containing

\item[{Return q\_pca}] \leavevmode
srsf principal directions

\item[{Return f\_pca}] \leavevmode
functional principal directions

\item[{Return latent}] \leavevmode
latent values

\item[{Return coef}] \leavevmode
coefficients

\item[{Return U}] \leavevmode
eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (fPCA.fdavpca method)@\spxentry{plot()}\spxextra{fPCA.fdavpca method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPCA:fPCA.fdavpca.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{}{}
plot plot elastic vertical fPCA result
Usage: obj.plot()

\end{fulllineitems}


\end{fulllineitems}



\chapter{Elastic Functional Boxplots}
\label{\detokenize{boxplots:module-boxplots}}\label{\detokenize{boxplots:elastic-functional-boxplots}}\label{\detokenize{boxplots::doc}}\index{module@\spxentry{module}!boxplots@\spxentry{boxplots}}\index{boxplots@\spxentry{boxplots}!module@\spxentry{module}}
Elastic Functional Boxplots

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{ampbox (class in boxplots)@\spxentry{ampbox}\spxextra{class in boxplots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{boxplots:boxplots.ampbox}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{boxplots.}}\sphinxbfcode{\sphinxupquote{ampbox}}}{\emph{\DUrole{n}{fdawarp}}}{}
This class provides amplitude boxplot for functional data using the
SRVF framework

Usage:  obj = ampbox(warp\_data)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warp\_data}} ({\hyperref[\detokenize{time_warping:time_warping.fdawarp}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{fdawarp}}}}}) \textendash{} fdawarp class with alignment data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q1}} \textendash{} First quartile

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q3}} \textendash{} Second quartile

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q1a}} \textendash{} First quantile based on alpha

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q3a}} \textendash{} Second quantile based on alpha

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{minn}} \textendash{} minimum extreme function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{maxx}} \textendash{} maximum extreme function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outlier\_index}} \textendash{} indexes of outlier functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f\_median}} \textendash{} median function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q\_median}} \textendash{} median srvf

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plt}} \textendash{} surface plot mesh

\end{itemize}

\end{description}\end{quote}

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  15\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{construct\_boxplot() (boxplots.ampbox method)@\spxentry{construct\_boxplot()}\spxextra{boxplots.ampbox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{boxplots:boxplots.ampbox.construct_boxplot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{construct\_boxplot}}}{\emph{\DUrole{n}{alpha}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{k\_a}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
This function constructs the amplitude boxplot using the elastic
square\sphinxhyphen{}root slope (srsf) framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} quantile value (e.g.,=.05, i.e., 95\%)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k\_a}} \textendash{} scalar for outlier cutoff (e.g.,=1)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (boxplots.ampbox method)@\spxentry{plot()}\spxextra{boxplots.ampbox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{boxplots:boxplots.ampbox.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{}{}
plot box plot and surface plot

Usage: obj.plot()

\end{fulllineitems}


\end{fulllineitems}

\index{phbox (class in boxplots)@\spxentry{phbox}\spxextra{class in boxplots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{boxplots:boxplots.phbox}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{boxplots.}}\sphinxbfcode{\sphinxupquote{phbox}}}{\emph{\DUrole{n}{fdawarp}}}{}
This class provides phase boxplot for functional data using the
SRVF framework

Usage:  obj = phbox(warp\_data)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warp\_data}} ({\hyperref[\detokenize{time_warping:time_warping.fdawarp}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{fdawarp}}}}}) \textendash{} fdawarp class with alignment data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q1}} \textendash{} First quartile

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q3}} \textendash{} Second quartile

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q1a}} \textendash{} First quantile based on alpha

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q3a}} \textendash{} Second quantile based on alpha

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{minn}} \textendash{} minimum extreme function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{maxx}} \textendash{} maximum extreme function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outlier\_index}} \textendash{} indexes of outlier functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{median\_x}} \textendash{} median warping function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{psi\_median}} \textendash{} median srvf of warping function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plt}} \textendash{} surface plot mesh

\end{itemize}

\end{description}\end{quote}

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  15\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{construct\_boxplot() (boxplots.phbox method)@\spxentry{construct\_boxplot()}\spxextra{boxplots.phbox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{boxplots:boxplots.phbox.construct_boxplot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{construct\_boxplot}}}{\emph{\DUrole{n}{alpha}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{k\_a}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
This function constructs phase boxplot for functional data using the elastic
square\sphinxhyphen{}root slope (srsf) framework.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} quantile value (e.g.,=.05, i.e., 95\%)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k\_a}} \textendash{} scalar for outlier cutoff (e.g.,=1)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (boxplots.phbox method)@\spxentry{plot()}\spxextra{boxplots.phbox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{boxplots:boxplots.phbox.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{}{}
plot box plot and surface plot

Usage: obj.plot()

\end{fulllineitems}


\end{fulllineitems}



\chapter{Functional Principal Least Squares}
\label{\detokenize{fPLS:module-fPLS}}\label{\detokenize{fPLS:functional-principal-least-squares}}\label{\detokenize{fPLS::doc}}\index{module@\spxentry{module}!fPLS@\spxentry{fPLS}}\index{fPLS@\spxentry{fPLS}!module@\spxentry{module}}
Partial Least Squares using SVD

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{pls\_svd() (in module fPLS)@\spxentry{pls\_svd()}\spxextra{in module fPLS}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fPLS:fPLS.pls_svd}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{fPLS.}}\sphinxbfcode{\sphinxupquote{pls\_svd}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{qf}}, \emph{\DUrole{n}{qg}}, \emph{\DUrole{n}{no}}, \emph{\DUrole{n}{alpha}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
This function computes the partial least squares using SVD
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector describing time samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{qf}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{qg}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} \textendash{} number of components

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} amount of smoothing (Default = 0.0 i.e., none)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return wqf}] \leavevmode
f weight function

\item[{Return wqg}] \leavevmode
g weight function

\item[{Return alpha}] \leavevmode
smoothing value

\item[{Return values}] \leavevmode
singular values

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Elastic Regression}
\label{\detokenize{regression:module-regression}}\label{\detokenize{regression:elastic-regression}}\label{\detokenize{regression::doc}}\index{module@\spxentry{module}!regression@\spxentry{regression}}\index{regression@\spxentry{regression}!module@\spxentry{module}}
Warping Invariant Regression using SRSF

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{elastic\_logistic() (in module regression)@\spxentry{elastic\_logistic()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.elastic_logistic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{elastic\_logistic}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{B}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{df}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{max\_itr}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}, \emph{\DUrole{n}{smooth}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function identifies a logistic regression model with
phase\sphinxhyphen{}variability using elastic methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy array of labels (1/\sphinxhyphen{}1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{B}} \textendash{} optional matrix describing Basis elements

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} \textendash{} number of degrees of freedom B\sphinxhyphen{}spline (default 20)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_itr}} \textendash{} maximum number of iterations (default 20)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cores}} \textendash{} number of cores for parallel processing (default all)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return alpha}] \leavevmode
alpha parameter of model

\item[{Return beta}] \leavevmode
beta(t) of model

\item[{Return fn}] \leavevmode
aligned functions \sphinxhyphen{} numpy ndarray of shape (M,N) of M

\end{description}\end{quote}

functions with N samples
:return qn: aligned srvfs \sphinxhyphen{} similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return Loss: logistic loss

\end{fulllineitems}

\index{elastic\_mlogistic() (in module regression)@\spxentry{elastic\_mlogistic()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.elastic_mlogistic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{elastic\_mlogistic}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{B}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{df}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{max\_itr}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}, \emph{\DUrole{n}{delta}\DUrole{o}{=}\DUrole{default_value}{0.01}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{smooth}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function identifies a multinomial logistic regression model with
phase\sphinxhyphen{}variability using elastic methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy array of labels \{1,2,…,m\} for m classes

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{B}} \textendash{} optional matrix describing Basis elements

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} \textendash{} number of degrees of freedom B\sphinxhyphen{}spline (default 20)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_itr}} \textendash{} maximum number of iterations (default 20)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cores}} \textendash{} number of cores for parallel processing (default all)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return alpha}] \leavevmode
alpha parameter of model

\item[{Return beta}] \leavevmode
beta(t) of model

\item[{Return fn}] \leavevmode
aligned functions \sphinxhyphen{} numpy ndarray of shape (M,N) of N

\end{description}\end{quote}

functions with M samples
:return qn: aligned srvfs \sphinxhyphen{} similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return Loss: logistic loss

\end{fulllineitems}

\index{elastic\_prediction() (in module regression)@\spxentry{elastic\_prediction()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.elastic_prediction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{elastic\_prediction}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{model}}, \emph{\DUrole{n}{y}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{smooth}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function performs prediction from an elastic regression model
with phase\sphinxhyphen{}variability
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} identified model from elastic\_regression

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} truth, optional used to calculate SSE

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return alpha}] \leavevmode
alpha parameter of model

\item[{Return beta}] \leavevmode
beta(t) of model

\item[{Return fn}] \leavevmode
aligned functions \sphinxhyphen{} numpy ndarray of shape (M,N) of N

\end{description}\end{quote}

functions with M samples
:return qn: aligned srvfs \sphinxhyphen{} similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return SSE: sum of squared error

\end{fulllineitems}

\index{elastic\_regression() (in module regression)@\spxentry{elastic\_regression()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.elastic_regression}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{elastic\_regression}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{B}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{lam}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{df}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{max\_itr}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}, \emph{\DUrole{n}{smooth}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function identifies a regression model with phase\sphinxhyphen{}variability
using elastic methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy array of N responses

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{B}} \textendash{} optional matrix describing Basis elements

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} \textendash{} regularization parameter (default 0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} \textendash{} number of degrees of freedom B\sphinxhyphen{}spline (default 20)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_itr}} \textendash{} maximum number of iterations (default 20)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cores}} \textendash{} number of cores for parallel processing (default all)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return alpha}] \leavevmode
alpha parameter of model

\item[{Return beta}] \leavevmode
beta(t) of model

\item[{Return fn}] \leavevmode
aligned functions \sphinxhyphen{} numpy ndarray of shape (M,N) of M

\end{description}\end{quote}

functions with N samples
:return qn: aligned srvfs \sphinxhyphen{} similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return SSE: sum of squared error

\end{fulllineitems}

\index{logistic\_warp() (in module regression)@\spxentry{logistic\_warp()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.logistic_warp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{logistic\_warp}}}{\emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{q}}, \emph{\DUrole{n}{y}}}{}
calculates optimal warping for function logistic regression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy ndarray of shape (1,N) responses

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return gamma}] \leavevmode
warping function

\end{description}\end{quote}

\end{fulllineitems}

\index{logit\_gradient() (in module regression)@\spxentry{logit\_gradient()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.logit_gradient}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{logit\_gradient}}}{\emph{\DUrole{n}{b}}, \emph{\DUrole{n}{X}}, \emph{\DUrole{n}{y}}}{}
calculates gradient of the logistic loss
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy ndarray of shape (1,N) responses

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return grad}] \leavevmode
gradient of logistic loss

\end{description}\end{quote}

\end{fulllineitems}

\index{logit\_hessian() (in module regression)@\spxentry{logit\_hessian()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.logit_hessian}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{logit\_hessian}}}{\emph{\DUrole{n}{s}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{X}}, \emph{\DUrole{n}{y}}}{}
calculates hessian of the logistic loss
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy ndarray of shape (1,N) responses

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return out}] \leavevmode
hessian of logistic loss

\end{description}\end{quote}

\end{fulllineitems}

\index{logit\_loss() (in module regression)@\spxentry{logit\_loss()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.logit_loss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{logit\_loss}}}{\emph{\DUrole{n}{b}}, \emph{\DUrole{n}{X}}, \emph{\DUrole{n}{y}}}{}
logistic loss function, returns Sum\{\sphinxhyphen{}log(phi(t))\}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy ndarray of shape (1,N) of N responses

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return out}] \leavevmode
loss value

\end{description}\end{quote}

\end{fulllineitems}

\index{mlogit\_gradient() (in module regression)@\spxentry{mlogit\_gradient()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.mlogit_gradient}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{mlogit\_gradient}}}{\emph{\DUrole{n}{b}}, \emph{\DUrole{n}{X}}, \emph{\DUrole{n}{Y}}}{}
calculates gradient of the multinomial logistic loss
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy ndarray of shape (1,N) responses

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return grad}] \leavevmode
gradient

\end{description}\end{quote}

\end{fulllineitems}

\index{mlogit\_loss() (in module regression)@\spxentry{mlogit\_loss()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.mlogit_loss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{mlogit\_loss}}}{\emph{\DUrole{n}{b}}, \emph{\DUrole{n}{X}}, \emph{\DUrole{n}{Y}}}{}
calculates multinomial logistic loss (negative log\sphinxhyphen{}likelihood)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy ndarray of shape (1,N) responses

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return nll}] \leavevmode
negative log\sphinxhyphen{}likelihood

\end{description}\end{quote}

\end{fulllineitems}

\index{mlogit\_warp\_grad() (in module regression)@\spxentry{mlogit\_warp\_grad()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.mlogit_warp_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{mlogit\_warp\_grad}}}{\emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{q}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{max\_itr}\DUrole{o}{=}\DUrole{default_value}{8000}}, \emph{\DUrole{n}{tol}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}10}}, \emph{\DUrole{n}{delta}\DUrole{o}{=}\DUrole{default_value}{0.008}}, \emph{\DUrole{n}{display}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
calculates optimal warping for functional multinomial logistic regression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} scalar

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy ndarray of shape (1,N) responses

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_itr}} \textendash{} maximum number of iterations (Default=8000)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tol}} \textendash{} stopping tolerance (Default=1e\sphinxhyphen{}10)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delta}} \textendash{} gradient step size (Default=0.008)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{display}} \textendash{} display iterations (Default=0)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy array

\item[{Return gam\_old}] \leavevmode
warping function

\end{description}\end{quote}

\end{fulllineitems}

\index{phi() (in module regression)@\spxentry{phi()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.phi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{phi}}}{\emph{\DUrole{n}{t}}}{}
calculates logistic function, returns 1 / (1 + exp(\sphinxhyphen{}t))
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} scalar

\item[{Return type}] \leavevmode
numpy array

\item[{Return out}] \leavevmode
return value

\end{description}\end{quote}

\end{fulllineitems}

\index{regression\_warp() (in module regression)@\spxentry{regression\_warp()}\spxextra{in module regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regression:regression.regression_warp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regression.}}\sphinxbfcode{\sphinxupquote{regression\_warp}}}{\emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{q}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{alpha}}}{}
calculates optimal warping for function linear regression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy ndarray of shape (1,N) of M functions with N samples

\end{itemize}

\end{description}\end{quote}

responses
:param alpha: numpy scalar
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy array

\item[{Return gamma\_new}] \leavevmode
warping function

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Elastic Principal Component Regression}
\label{\detokenize{pcr_regression:module-pcr_regression}}\label{\detokenize{pcr_regression:elastic-principal-component-regression}}\label{\detokenize{pcr_regression::doc}}\index{module@\spxentry{module}!pcr\_regression@\spxentry{pcr\_regression}}\index{pcr\_regression@\spxentry{pcr\_regression}!module@\spxentry{module}}
Warping Invariant PCR Regression using SRSF

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{elastic\_lpcr\_regression (class in pcr\_regression)@\spxentry{elastic\_lpcr\_regression}\spxextra{class in pcr\_regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_lpcr_regression}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pcr\_regression.}}\sphinxbfcode{\sphinxupquote{elastic\_lpcr\_regression}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{time}}}{}
This class provides elastic logistic pcr regression for functional 
data using the SRVF framework accounting for warping

Usage:  obj = elastic\_lpcr\_regression(f,y,time)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} (M,N) \% matrix defining N functions of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} response vector of length N (\sphinxhyphen{}1/1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warp\_data}} \textendash{} fdawarp object of alignment

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pca}} \textendash{} class dependent on fPCA method used object of fPCA

\end{itemize}

\end{description}\end{quote}

:param information
:param alpha: intercept
:param b: coefficient vector
:param Loss: logistic loss
:param PC: probability of classification
:param ylabels: predicted labels

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  18\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{calc\_model() (pcr\_regression.elastic\_lpcr\_regression method)@\spxentry{calc\_model()}\spxextra{pcr\_regression.elastic\_lpcr\_regression method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_lpcr_regression.calc_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_model}}}{\emph{\DUrole{n}{pca\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}combined\textquotesingle{}}}, \emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{smooth\_data}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sparam}\DUrole{o}{=}\DUrole{default_value}{25}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function identifies a logistic regression model with phase\sphinxhyphen{}variability
using elastic pca
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pca\_method}} \textendash{} string specifing pca method (options = “combined”,
“vert”, or “horiz”, default = “combined”)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} \textendash{} scalar specify number of principal components (default=5)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth\_data}} \textendash{} smooth data using box filter (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sparam}} \textendash{} number of times to apply box filter (default = 25)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} calculate in parallel (default = F)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{predict() (pcr\_regression.elastic\_lpcr\_regression method)@\spxentry{predict()}\spxextra{pcr\_regression.elastic\_lpcr\_regression method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_lpcr_regression.predict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{predict}}}{\emph{\DUrole{n}{newdata}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This function performs prediction on regression model on new data if available or current stored data in object
Usage:  obj.predict()
\begin{quote}

obj.predict(newdata)
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{newdata}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} dict containing new data for prediction (needs the keys below, if None predicts on training data)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} (M,N) matrix of functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of time points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} truth if available

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth}} \textendash{} smooth data if needed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sparam}} \textendash{} number of times to run filter

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{elastic\_mlpcr\_regression (class in pcr\_regression)@\spxentry{elastic\_mlpcr\_regression}\spxextra{class in pcr\_regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_mlpcr_regression}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pcr\_regression.}}\sphinxbfcode{\sphinxupquote{elastic\_mlpcr\_regression}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{time}}}{}
This class provides elastic multinomial logistic pcr regression for functional
data using the SRVF framework accounting for warping

Usage:  obj = elastic\_mlpcr\_regression(f,y,time)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} (M,N) \% matrix defining N functions of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} response vector of length N

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Y}} \textendash{} coded label matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warp\_data}} \textendash{} fdawarp object of alignment

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pca}} \textendash{} class dependent on fPCA method used object of fPCA

\end{itemize}

\end{description}\end{quote}

:param information
:param alpha: intercept
:param b: coefficient vector
:param Loss: logistic loss
:param PC: probability of classification
:param ylabels: predicted labels
:param

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  18\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{calc\_model() (pcr\_regression.elastic\_mlpcr\_regression method)@\spxentry{calc\_model()}\spxextra{pcr\_regression.elastic\_mlpcr\_regression method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_mlpcr_regression.calc_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_model}}}{\emph{\DUrole{n}{pca\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}combined\textquotesingle{}}}, \emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{smooth\_data}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sparam}\DUrole{o}{=}\DUrole{default_value}{25}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function identifies a logistic regression model with phase\sphinxhyphen{}variability
using elastic pca
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} numpy array of N responses

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pca\_method}} \textendash{} string specifing pca method (options = “combined”,
“vert”, or “horiz”, default = “combined”)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} \textendash{} scalar specify number of principal components (default=5)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth\_data}} \textendash{} smooth data using box filter (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sparam}} \textendash{} number of times to apply box filter (default = 25)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} run model in parallel (default = F)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{predict() (pcr\_regression.elastic\_mlpcr\_regression method)@\spxentry{predict()}\spxextra{pcr\_regression.elastic\_mlpcr\_regression method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_mlpcr_regression.predict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{predict}}}{\emph{\DUrole{n}{newdata}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This function performs prediction on regression model on new data if available or current stored data in object
Usage:  obj.predict()
\begin{quote}

obj.predict(newdata)
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{newdata}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} dict containing new data for prediction (needs the keys below, if None predicts on training data)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} (M,N) matrix of functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of time points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} truth if available

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth}} \textendash{} smooth data if needed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sparam}} \textendash{} number of times to run filter

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{elastic\_pcr\_regression (class in pcr\_regression)@\spxentry{elastic\_pcr\_regression}\spxextra{class in pcr\_regression}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_pcr_regression}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pcr\_regression.}}\sphinxbfcode{\sphinxupquote{elastic\_pcr\_regression}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{time}}}{}
This class provides elastic pcr regression for functional data using the
SRVF framework accounting for warping

Usage:  obj = elastic\_pcr\_regression(f,y,time)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} (M,N) \% matrix defining N functions of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} response vector of length N

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warp\_data}} \textendash{} fdawarp object of alignment

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pca}} \textendash{} class dependent on fPCA method used object of fPCA

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} intercept

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} coefficient vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{SSE}} \textendash{} sum of squared errors

\end{itemize}

\end{description}\end{quote}

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  18\sphinxhyphen{}Mar\sphinxhyphen{}2018
\index{calc\_model() (pcr\_regression.elastic\_pcr\_regression method)@\spxentry{calc\_model()}\spxextra{pcr\_regression.elastic\_pcr\_regression method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_pcr_regression.calc_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_model}}}{\emph{\DUrole{n}{pca\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}combined\textquotesingle{}}}, \emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{smooth\_data}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sparam}\DUrole{o}{=}\DUrole{default_value}{25}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{C}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This function identifies a regression model with phase\sphinxhyphen{}variability
using elastic pca
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pca\_method}} \textendash{} string specifing pca method (options = “combined”,
“vert”, or “horiz”, default = “combined”)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} \textendash{} scalar specify number of principal components (default=5)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth\_data}} \textendash{} smooth data using box filter (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sparam}} \textendash{} number of times to apply box filter (default = 25)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} run in parallel (default = F)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{C}} \textendash{} scale balance parameter for combined method (default = None)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{predict() (pcr\_regression.elastic\_pcr\_regression method)@\spxentry{predict()}\spxextra{pcr\_regression.elastic\_pcr\_regression method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pcr_regression:pcr_regression.elastic_pcr_regression.predict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{predict}}}{\emph{\DUrole{n}{newdata}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This function performs prediction on regression model on new data if available or current stored data in object
Usage:  obj.predict()
\begin{quote}

obj.predict(newdata)
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{newdata}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} dict containing new data for prediction (needs the keys below, if None predicts on training data)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} (M,N) matrix of functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of time points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} truth if available

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth}} \textendash{} smooth data if needed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sparam}} \textendash{} number of times to run filter

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Elastic Functional Tolerance Bounds}
\label{\detokenize{tolerance:module-tolerance}}\label{\detokenize{tolerance:elastic-functional-tolerance-bounds}}\label{\detokenize{tolerance::doc}}\index{module@\spxentry{module}!tolerance@\spxentry{tolerance}}\index{tolerance@\spxentry{tolerance}!module@\spxentry{module}}
Functional Tolerance Bounds using SRSF

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{bootTB() (in module tolerance)@\spxentry{bootTB()}\spxextra{in module tolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tolerance:tolerance.bootTB}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tolerance.}}\sphinxbfcode{\sphinxupquote{bootTB}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{a}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{p}\DUrole{o}{=}\DUrole{default_value}{0.99}}, \emph{\DUrole{n}{B}\DUrole{o}{=}\DUrole{default_value}{500}}, \emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
This function computes tolerance bounds for functional data containing
phase and amplitude variation using bootstrap sampling
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a}} \textendash{} confidence level of tolerance bound (default = 0.05)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} coverage level of tolerance bound (default = 0.99)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{B}} \textendash{} number of bootstrap samples (default = 500)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} \textendash{} number of principal components (default = 5)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} enable parallel processing (default = T)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of boxplot objects

\item[{Return amp}] \leavevmode
amplitude tolerance bounds

\item[{Rtype out\_med}] \leavevmode
ampbox object

\item[{Return ph}] \leavevmode
phase tolerance bounds

\item[{Rtype out\_med}] \leavevmode
phbox object

\item[{Return out\_med}] \leavevmode
alignment results

\item[{Rtype out\_med}] \leavevmode
fdawarp object

\end{description}\end{quote}

\end{fulllineitems}

\index{mvtol\_region() (in module tolerance)@\spxentry{mvtol\_region()}\spxextra{in module tolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tolerance:tolerance.mvtol_region}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tolerance.}}\sphinxbfcode{\sphinxupquote{mvtol\_region}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{P}}, \emph{\DUrole{n}{B}}}{}
Computes tolerance factor for multivariate normal

Krishnamoorthy, K. and Mondal, S. (2006), Improved Tolerance Factors for Multivariate Normal
Distributions, Communications in Statistics \sphinxhyphen{} Simulation and Computation, 35, 461\textendash{}478.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} (M,N) matrix defining N variables of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} confidence level

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{P}} \textendash{} coverage level

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{B}} \textendash{} number of bootstrap samples

\end{itemize}

\item[{Return type}] \leavevmode
double

\item[{Return tol}] \leavevmode
tolerance factor

\end{description}\end{quote}

\end{fulllineitems}

\index{pcaTB() (in module tolerance)@\spxentry{pcaTB()}\spxextra{in module tolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tolerance:tolerance.pcaTB}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tolerance.}}\sphinxbfcode{\sphinxupquote{pcaTB}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{a}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{p}\DUrole{o}{=}\DUrole{default_value}{0.99}}, \emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
This function computes tolerance bounds for functional data containing
phase and amplitude variation using fPCA
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} numpy ndarray of shape (M,N) of N functions with M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a}} \textendash{} confidence level of tolerance bound (default = 0.05)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} coverage level of tolerance bound (default = 0.99)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} \textendash{} number of principal components (default = 5)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} enable parallel processing (default = T)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of boxplot objects

\item[{Return warp}] \leavevmode
alignment data from time\_warping

\item[{Return pca}] \leavevmode
functional pca from jointFPCA

\item[{Return tol}] \leavevmode
tolerance factor

\end{description}\end{quote}

\end{fulllineitems}

\index{rwishart() (in module tolerance)@\spxentry{rwishart()}\spxextra{in module tolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tolerance:tolerance.rwishart}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tolerance.}}\sphinxbfcode{\sphinxupquote{rwishart}}}{\emph{\DUrole{n}{df}}, \emph{\DUrole{n}{p}}}{}
Computes a random wishart matrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} \textendash{} degree of freedom

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} number of dimensions

\end{itemize}

\item[{Return type}] \leavevmode
double

\item[{Return R}] \leavevmode
matrix

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Curve Registration}
\label{\detokenize{curve_statistics:curve-registration}}\label{\detokenize{curve_statistics::doc}}\phantomsection\label{\detokenize{curve_statistics:module-curve_stats}}\index{module@\spxentry{module}!curve\_stats@\spxentry{curve\_stats}}\index{curve\_stats@\spxentry{curve\_stats}!module@\spxentry{module}}
statistic calculation for SRVF (curves) open and closed using Karcher
Mean and Variance

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{fdacurve (class in curve\_stats)@\spxentry{fdacurve}\spxextra{class in curve\_stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_statistics:curve_stats.fdacurve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{curve\_stats.}}\sphinxbfcode{\sphinxupquote{fdacurve}}}{\emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}O\textquotesingle{}}}, \emph{\DUrole{n}{N}\DUrole{o}{=}\DUrole{default_value}{200}}, \emph{\DUrole{n}{scale}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
This class provides alignment methods for open and closed curves using the SRVF framework

Usage: obj = fdacurve(beta, mode, N, scale)
:param beta: numpy ndarray of shape (n, M, N) describing N curves
in R\textasciicircum{}M
:param mode: Open (‘O’) or closed curve (‘C’) (default ‘O’)
:param N: resample curve to N points
:param scale: scale curve to length 1 (true/false)
:param q:        (n,T,K) matrix defining n dimensional srvf on T samples with K srvfs
:param betan:     aligned curves
:param qn:        aligned srvfs
:param basis:     calculated basis
:param beta\_mean: karcher mean curve
:param q\_mean:    karcher mean srvf
:param gams:      warping functions
:param v:         shooting vectors
:param C:         karcher covariance
:param s:         pca singular values
:param U:         pca singular vectors
:param coef:      pca coefficients
:param qun:       cost function
:param samples:   random samples
:param gamr:      random warping functions
:param cent:      center
:param scale:     scale
:param E:         energy

Author :  J. D. Tucker (JDT) \textless{}jdtuck AT sandia.gov\textgreater{}
Date   :  26\sphinxhyphen{}Aug\sphinxhyphen{}2020
\index{karcher\_cov() (curve\_stats.fdacurve method)@\spxentry{karcher\_cov()}\spxextra{curve\_stats.fdacurve method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_statistics:curve_stats.fdacurve.karcher_cov}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{karcher\_cov}}}{}{}
This calculates the mean of a set of curves

\end{fulllineitems}

\index{karcher\_mean() (curve\_stats.fdacurve method)@\spxentry{karcher\_mean()}\spxextra{curve\_stats.fdacurve method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_statistics:curve_stats.fdacurve.karcher_mean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{karcher\_mean}}}{\emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{}
This calculates the mean of a set of curves
:param parallel: run in parallel (default = F)
:param cores: number of cores for parallel (default = \sphinxhyphen{}1 (all))

\end{fulllineitems}

\index{plot() (curve\_stats.fdacurve method)@\spxentry{plot()}\spxextra{curve\_stats.fdacurve method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_statistics:curve_stats.fdacurve.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{}{}
plot curve mean results

\end{fulllineitems}

\index{sample\_shapes() (curve\_stats.fdacurve method)@\spxentry{sample\_shapes()}\spxextra{curve\_stats.fdacurve method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_statistics:curve_stats.fdacurve.sample_shapes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sample\_shapes}}}{\emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{numSamp}\DUrole{o}{=}\DUrole{default_value}{10}}}{}
Computes sample shapes from mean and covariance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no}} \textendash{} number of direction (default 3)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{numSamp}} \textendash{} number of samples (default 10)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{shape\_pca() (curve\_stats.fdacurve method)@\spxentry{shape\_pca()}\spxextra{curve\_stats.fdacurve method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_statistics:curve_stats.fdacurve.shape_pca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{shape\_pca}}}{\emph{\DUrole{n}{no}\DUrole{o}{=}\DUrole{default_value}{10}}}{}
Computes principal direction of variation specified by no. N is
Number of shapes away from mean. Creates 2*N+1 shape sequence
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{no}} \textendash{} number of direction (default 3)

\end{description}\end{quote}

\end{fulllineitems}

\index{srvf\_align() (curve\_stats.fdacurve method)@\spxentry{srvf\_align()}\spxextra{curve\_stats.fdacurve method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_statistics:curve_stats.fdacurve.srvf_align}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{srvf\_align}}}{\emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{}
This aligns a set of curves to the mean and computes mean if not computed
:param parallel: run in parallel (default = F)
:param cores: number of cores for parallel (default = \sphinxhyphen{}1 (all))

\end{fulllineitems}


\end{fulllineitems}

\index{randn() (in module curve\_stats)@\spxentry{randn()}\spxextra{in module curve\_stats}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_statistics:curve_stats.randn}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_stats.}}\sphinxbfcode{\sphinxupquote{randn}}}{\emph{d0}, \emph{d1}, \emph{...}, \emph{dn}}{}
Return a sample (or samples) from the “standard normal” distribution.

\begin{sphinxadmonition}{note}{Note:}
This is a convenience function for users porting code from Matlab,
and wraps \sphinxtitleref{standard\_normal}. That function takes a
tuple to specify the size of the output, which is consistent with
other NumPy functions like \sphinxtitleref{numpy.zeros} and \sphinxtitleref{numpy.ones}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{standard\_normal}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}

If positive int\_like arguments are provided, \sphinxtitleref{randn} generates an array
of shape \sphinxcode{\sphinxupquote{(d0, d1, ..., dn)}}, filled
with random floats sampled from a univariate “normal” (Gaussian)
distribution of mean 0 and variance 1. A single float randomly sampled
from the distribution is returned if no argument is provided.
\begin{description}
\item[{d0, d1, …, dn}] \leavevmode{[}int, optional{]}
The dimensions of the returned array, must be non\sphinxhyphen{}negative.
If no argument is given a single Python float is returned.

\end{description}
\begin{description}
\item[{Z}] \leavevmode{[}ndarray or float{]}
A \sphinxcode{\sphinxupquote{(d0, d1, ..., dn)}}\sphinxhyphen{}shaped array of floating\sphinxhyphen{}point samples from
the standard normal distribution, or a single such float if
no parameters were supplied.

\end{description}

standard\_normal : Similar, but takes a tuple as its argument.
normal : Also accepts mu and sigma arguments.
Generator.standard\_normal: which should be used for new code.

For random samples from \(N(\mu, \sigma^2)\), use:

\sphinxcode{\sphinxupquote{sigma * np.random.randn(...) + mu}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{2.1923875335537315  \PYGZsh{} random}
\end{sphinxVerbatim}

Two\sphinxhyphen{}by\sphinxhyphen{}four array of samples from N(3, 6.25):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mf}{2.5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}4.49401501,  4.00950034, \PYGZhy{}1.81814867,  7.29718677],   \PYGZsh{} random}
\PYG{g+go}{       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}



\chapter{SRVF Geodesic Computation}
\label{\detokenize{geodesic:module-geodesic}}\label{\detokenize{geodesic:srvf-geodesic-computation}}\label{\detokenize{geodesic::doc}}\index{module@\spxentry{module}!geodesic@\spxentry{geodesic}}\index{geodesic@\spxentry{geodesic}!module@\spxentry{module}}
geodesic calculation for SRVF (curves) open and closed

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{back\_parallel\_transport() (in module geodesic)@\spxentry{back\_parallel\_transport()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.back_parallel_transport}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{back\_parallel\_transport}}}{\emph{\DUrole{n}{u1}}, \emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
backwards parallel translates q1 and q2 along manifold
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{u1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basis}} \textendash{} list numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return utilde}] \leavevmode
translated vector

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_alphadot() (in module geodesic)@\spxentry{calc\_alphadot()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.calc_alphadot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{calc\_alphadot}}}{\emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
calculates derivative along the path alpha
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basis}} \textendash{} list of numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return alphadot}] \leavevmode
derivative of alpha

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_energy() (in module geodesic)@\spxentry{calculate\_energy()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.calculate_energy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{calculate\_energy}}}{\emph{\DUrole{n}{alphadot}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
calculates energy along path
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alphadot}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy scalar

\item[{Return E}] \leavevmode
energy

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_gradE() (in module geodesic)@\spxentry{calculate\_gradE()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.calculate_gradE}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{calculate\_gradE}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{utilde}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
calculates gradient of energy along path
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{u}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{utilde}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy scalar

\item[{Return gradE}] \leavevmode
gradient of energy

\item[{Return normgradE}] \leavevmode
norm of gradient of energy

\end{description}\end{quote}

\end{fulllineitems}

\index{cov\_integral() (in module geodesic)@\spxentry{cov\_integral()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.cov_integral}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{cov\_integral}}}{\emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{alphadot}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
Calculates covariance along path alpha
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} numpy ndarray of shape (2,M) of M samples (first curve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alphadot}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basis}} \textendash{} list numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return u}] \leavevmode
covariance

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_basis\_normal\_path() (in module geodesic)@\spxentry{find\_basis\_normal\_path()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.find_basis_normal_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{find\_basis\_normal\_path}}}{\emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
computes orthonormalized basis vectors to the normal space at each of the
k points (q\sphinxhyphen{}functions) of the path alpha
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} numpy ndarray of shape (2,M) of M samples (path)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return basis}] \leavevmode
basis vectors along the path

\end{description}\end{quote}

\end{fulllineitems}

\index{geod\_dist\_path\_strt() (in module geodesic)@\spxentry{geod\_dist\_path\_strt()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.geod_dist_path_strt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{geod\_dist\_path\_strt}}}{\emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
calculate geodisc distance for path straightening
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy scalar

\item[{Return dist}] \leavevmode
geodesic distance

\end{description}\end{quote}

\end{fulllineitems}

\index{geod\_sphere() (in module geodesic)@\spxentry{geod\_sphere()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.geod_sphere}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{geod\_sphere}}}{\emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta2}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
This function calculates the geodesics between open curves beta1 and
beta2 with k steps along path
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return dist}] \leavevmode
geodesic distance

\item[{Return path}] \leavevmode
geodesic path

\item[{Return O}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_path\_geod() (in module geodesic)@\spxentry{init\_path\_geod()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.init_path_geod}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{init\_path\_geod}}}{\emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta2}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
Initializes a path in cal\{C\}. beta1, beta2 are already
standardized curves. Creates a path from beta1 to beta2 in
shape space, then projects to the closed shape manifold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta1}} \textendash{} numpy ndarray of shape (2,M) of M samples (first curve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} \textendash{} numpy ndarray of shape (2,M) of M samples (end curve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return alpha}] \leavevmode
a path between two q\sphinxhyphen{}functions

\item[{Return beta}] \leavevmode
a path between two curves

\item[{Return O}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_path\_rand() (in module geodesic)@\spxentry{init\_path\_rand()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.init_path_rand}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{init\_path\_rand}}}{\emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta\_mid}}, \emph{\DUrole{n}{beta2}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
Initializes a path in cal\{C\}. beta1, beta\_mid beta2 are already
standardized curves. Creates a path from beta1 to beta\_mid to beta2 in
shape space, then projects to the closed shape manifold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta1}} \textendash{} numpy ndarray of shape (2,M) of M samples (first curve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{betamid}} \textendash{} numpy ndarray of shape (2,M) of M samples (mid curve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} \textendash{} numpy ndarray of shape (2,M) of M samples (end curve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return alpha}] \leavevmode
a path between two q\sphinxhyphen{}functions

\item[{Return beta}] \leavevmode
a path between two curves

\item[{Return O}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{path\_straightening() (in module geodesic)@\spxentry{path\_straightening()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.path_straightening}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{path\_straightening}}}{\emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta2}}, \emph{\DUrole{n}{betamid}}, \emph{\DUrole{n}{init}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}rand\textquotesingle{}}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
Perform path straightening to find geodesic between two shapes in either
the space of closed curves or the space of affine standardized curves.
This algorithm follows the steps outlined in section 4.6 of the
manuscript.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta1}} \textendash{} numpy ndarray of shape (2,M) of M samples (first curve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} \textendash{} numpy ndarray of shape (2,M) of M samples (end curve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{betamid}} \textendash{} numpy ndarray of shape (2,M) of M samples (mid curve
Default = NULL, only needed for init “rand”)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init}} \textendash{} initialize path geodesic or random (Default = “rand”)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return dist}] \leavevmode
geodesic distance

\item[{Return path}] \leavevmode
geodesic path

\item[{Return pathsqnc}] \leavevmode
geodesic path sequence

\item[{Return E}] \leavevmode
energy

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_path() (in module geodesic)@\spxentry{update\_path()}\spxextra{in module geodesic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{geodesic:geodesic.update_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{geodesic.}}\sphinxbfcode{\sphinxupquote{update\_path}}}{\emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{gradE}}, \emph{\DUrole{n}{delta}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
Update the path along the direction \sphinxhyphen{}gradE
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gradE}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delta}} \textendash{} gradient paramenter

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} Number of samples of curve (Default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} number of samples along path (Default = 5)

\end{itemize}

\item[{Return type}] \leavevmode
numpy scalar

\item[{Return alpha}] \leavevmode
updated path of srvfs

\item[{Return beta}] \leavevmode
updated path of curves

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Utility Functions}
\label{\detokenize{utility_functions:module-utility_functions}}\label{\detokenize{utility_functions:utility-functions}}\label{\detokenize{utility_functions::doc}}\index{module@\spxentry{module}!utility\_functions@\spxentry{utility\_functions}}\index{utility\_functions@\spxentry{utility\_functions}!module@\spxentry{module}}
Utility functions for SRSF Manipulations

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{SqrtMean() (in module utility\_functions)@\spxentry{SqrtMean()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.SqrtMean}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{SqrtMean}}}{\emph{\DUrole{n}{gam}}}{}
calculates the srsf of warping functions with corresponding shooting vectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{gam}} \textendash{} numpy ndarray of shape (M,N) of M warping functions
with N samples

\item[{Return type}] \leavevmode
2 numpy ndarray and vector

\item[{Return mu}] \leavevmode
Karcher mean psi function

\item[{Return gam\_mu}] \leavevmode
vector of dim N which is the Karcher mean warping function

\item[{Return psi}] \leavevmode
numpy ndarray of shape (M,N) of M SRSF of the warping functions

\item[{Return vec}] \leavevmode
numpy ndarray of shape (M,N) of M shooting vectors

\end{description}\end{quote}

\end{fulllineitems}

\index{SqrtMeanInverse() (in module utility\_functions)@\spxentry{SqrtMeanInverse()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.SqrtMeanInverse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{SqrtMeanInverse}}}{\emph{\DUrole{n}{gam}}}{}
finds the inverse of the mean of the set of the diffeomorphisms gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{gam}} \textendash{} numpy ndarray of shape (M,N) of M warping functions
with N samples

\item[{Return type}] \leavevmode
vector

\item[{Return gamI}] \leavevmode
inverse of gam

\end{description}\end{quote}

\end{fulllineitems}

\index{SqrtMedian() (in module utility\_functions)@\spxentry{SqrtMedian()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.SqrtMedian}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{SqrtMedian}}}{\emph{\DUrole{n}{gam}}}{}
calculates the median srsf of warping functions with corresponding shooting vectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{gam}} \textendash{} numpy ndarray of shape (M,N) of M warping functions
with N samples

\item[{Return type}] \leavevmode
2 numpy ndarray and vector

\item[{Return gam\_median}] \leavevmode
Karcher median warping function

\item[{Return psi\_meidan}] \leavevmode
vector of dim N which is the Karcher median srsf function

\item[{Return psi}] \leavevmode
numpy ndarray of shape (M,N) of M SRSF of the warping functions

\item[{Return vec}] \leavevmode
numpy ndarray of shape (M,N) of M shooting vectors

\end{description}\end{quote}

\end{fulllineitems}

\index{cumtrapzmid() (in module utility\_functions)@\spxentry{cumtrapzmid()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.cumtrapzmid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{cumtrapzmid}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{c}}, \emph{\DUrole{n}{mid}}}{}
cumulative trapezoidal numerical integration taken from midpoint
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} vector of size N describing the time samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} vector of size N describing the function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} midpoint

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mid}} \textendash{} midpiont location

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return fa}] \leavevmode
cumulative integration

\end{description}\end{quote}

\end{fulllineitems}

\index{diffop() (in module utility\_functions)@\spxentry{diffop()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.diffop}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{diffop}}}{\emph{\DUrole{n}{n}}, \emph{\DUrole{n}{binsize}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Creates a second order differential operator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n}} \textendash{} dimension

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{binsize}} \textendash{} dx (default = 1)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return m}] \leavevmode
matrix describing differential operator

\end{description}\end{quote}

\end{fulllineitems}

\index{elastic\_depth() (in module utility\_functions)@\spxentry{elastic\_depth()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.elastic_depth}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{elastic\_depth}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{lam}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{parallel}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
calculates the elastic depth between functions in matrix f
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} matrix of size MxN (M time points for N functions)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size M describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} \textendash{} controls the elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
scalar

\item[{Return amp}] \leavevmode
amplitude depth

\item[{Return phase}] \leavevmode
phase depth

\end{description}\end{quote}

\end{fulllineitems}

\index{elastic\_distance() (in module utility\_functions)@\spxentry{elastic\_distance()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.elastic_distance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{elastic\_distance}}}{\emph{\DUrole{n}{f1}}, \emph{\DUrole{n}{f2}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}DP\textquotesingle{}}}, \emph{\DUrole{n}{lam}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
”
calculates the distances between function, where f1 is aligned to
f2. In other words
calculates the elastic distances
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f1}} \textendash{} vector of size N

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f2}} \textendash{} vector of size N

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} \textendash{} controls the elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
scalar

\item[{Return Dy}] \leavevmode
amplitude distance

\item[{Return Dx}] \leavevmode
phase distance

\end{description}\end{quote}

\end{fulllineitems}

\index{f\_K\_fold() (in module utility\_functions)@\spxentry{f\_K\_fold()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.f_K_fold}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{f\_K\_fold}}}{\emph{\DUrole{n}{Nobs}}, \emph{\DUrole{n}{K}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
generates sample indices for K\sphinxhyphen{}fold cross validation

:param Nobs number of observations
:param K number of folds
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return train}] \leavevmode
train indexes (Nobs*(K\sphinxhyphen{}1)/K X K)

\item[{Return test}] \leavevmode
test indexes (Nobs*(1/K) X K)

\end{description}\end{quote}

\end{fulllineitems}

\index{f\_to\_srsf() (in module utility\_functions)@\spxentry{f\_to\_srsf()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.f_to_srsf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{f\_to\_srsf}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{smooth}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
converts f to a square\sphinxhyphen{}root slope function (SRSF)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} vector of size N samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return q}] \leavevmode
srsf of f

\end{description}\end{quote}

\end{fulllineitems}

\index{geigen() (in module utility\_functions)@\spxentry{geigen()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.geigen}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{geigen}}}{\emph{\DUrole{n}{Amat}}, \emph{\DUrole{n}{Bmat}}, \emph{\DUrole{n}{Cmat}}}{}
generalized eigenvalue problem of the form

max tr L’AM / sqrt(tr L’BL tr M’CM) w.r.t. L and M

:param Amat numpy ndarray of shape (M,N)
:param Bmat numpy ndarray of shape (M,N)
:param Bmat numpy ndarray of shape (M,N)
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return values}] \leavevmode
eigenvalues

\item[{Return Lmat}] \leavevmode
left eigenvectors

\item[{Return Mmat}] \leavevmode
right eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{gradient\_spline() (in module utility\_functions)@\spxentry{gradient\_spline()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.gradient_spline}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{gradient\_spline}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{f}}, \emph{\DUrole{n}{smooth}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function takes the gradient of f using b\sphinxhyphen{}spline smoothing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smooth}} \textendash{} smooth data (default = F)

\end{itemize}

\item[{Return type}] \leavevmode
tuple of numpy ndarray

\item[{Return f0}] \leavevmode
smoothed functions functions

\item[{Return g}] \leavevmode
first derivative of each function

\item[{Return g2}] \leavevmode
second derivative of each function

\end{description}\end{quote}

\end{fulllineitems}

\index{innerprod\_q() (in module utility\_functions)@\spxentry{innerprod\_q()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.innerprod_q}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{innerprod\_q}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}}{}
calculates the innerproduct between two srsfs

:param time vector descrbing time samples
:param q1 vector of srsf 1
:param q2 vector of srsf 2
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
scalar

\item[{Return val}] \leavevmode
inner product value

\end{description}\end{quote}

\end{fulllineitems}

\index{invertGamma() (in module utility\_functions)@\spxentry{invertGamma()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.invertGamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{invertGamma}}}{\emph{\DUrole{n}{gam}}}{}
finds the inverse of the diffeomorphism gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{gam}} \textendash{} vector describing the warping function

\item[{Return type}] \leavevmode
vector

\item[{Return gamI}] \leavevmode
inverse of gam

\end{description}\end{quote}

\end{fulllineitems}

\index{optimum\_reparam() (in module utility\_functions)@\spxentry{optimum\_reparam()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.optimum_reparam}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{optimum\_reparam}}}{\emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{q2}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}DP\textquotesingle{}}}, \emph{\DUrole{n}{lam}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{f1o}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{f2o}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
calculates the warping to align srsf q2 to q1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} vector of size N or array of NxM samples of first SRSF

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} vector of size N or array of NxM samples samples of second SRSF

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} \textendash{} method to apply optimization (default=”DP”) options are “DP”, “DP2” and “RBFGS”

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} \textendash{} controls the amount of elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return gam}] \leavevmode
describing the warping function used to align q2 with q1

\end{description}\end{quote}

\end{fulllineitems}

\index{optimum\_reparam\_pair() (in module utility\_functions)@\spxentry{optimum\_reparam\_pair()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.optimum_reparam_pair}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{optimum\_reparam\_pair}}}{\emph{\DUrole{n}{q}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}, \emph{\DUrole{n}{lam}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
calculates the warping to align srsf pair q1 and q2 to q
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} vector of size N or array of NxM samples of first SRSF

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} vector of size N or array of NxM samples samples of second SRSF

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} vector of size N or array of NxM samples samples of second SRSF

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} \textendash{} controls the amount of elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return gam}] \leavevmode
describing the warping function used to align q2 with q1

\end{description}\end{quote}

\end{fulllineitems}

\index{outlier\_detection() (in module utility\_functions)@\spxentry{outlier\_detection()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.outlier_detection}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{outlier\_detection}}}{\emph{\DUrole{n}{q}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{mq}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{1.5}}}{}
calculates outlier’s using geodesic distances of the SRSFs from the median
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray of N x M of M SRS functions with N samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mq}} \textendash{} median calculated using \sphinxcode{\sphinxupquote{time\_warping.srsf\_align()}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} cutoff threshold (default = 1.5)

\end{itemize}

\item[{Returns}] \leavevmode
q\_outlier: outlier functions

\end{description}\end{quote}

\end{fulllineitems}

\index{randomGamma() (in module utility\_functions)@\spxentry{randomGamma()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.randomGamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{randomGamma}}}{\emph{\DUrole{n}{gam}}, \emph{\DUrole{n}{num}}}{}
generates random warping functions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gam}} \textendash{} numpy ndarray of N x M of M of warping functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num}} \textendash{} number of random functions

\end{itemize}

\item[{Returns}] \leavevmode
rgam: random warping functions

\end{description}\end{quote}

\end{fulllineitems}

\index{resamplefunction() (in module utility\_functions)@\spxentry{resamplefunction()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.resamplefunction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{resamplefunction}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{n}}}{}
resample function using n points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n}} \textendash{} number of points

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return xn}] \leavevmode
resampled function

\end{description}\end{quote}

\end{fulllineitems}

\index{rgam() (in module utility\_functions)@\spxentry{rgam()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.rgam}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{rgam}}}{\emph{\DUrole{n}{N}}, \emph{\DUrole{n}{sigma}}, \emph{\DUrole{n}{num}}}{}
Generates random warping functions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{N}} \textendash{} length of warping function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigma}} \textendash{} variance of warping functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num}} \textendash{} number of warping functions

\end{itemize}

\item[{Returns}] \leavevmode
gam: numpy ndarray of warping functions

\end{description}\end{quote}

\end{fulllineitems}

\index{smooth\_data() (in module utility\_functions)@\spxentry{smooth\_data()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.smooth_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{smooth\_data}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{sparam}}}{}
This function smooths a collection of functions using a box filter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} numpy ndarray of shape (M,N) of M functions with N samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sparam}} \textendash{} Number of times to run box filter (default = 25)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return f}] \leavevmode
smoothed functions functions

\end{description}\end{quote}

\end{fulllineitems}

\index{srsf\_to\_f() (in module utility\_functions)@\spxentry{srsf\_to\_f()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.srsf_to_f}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{srsf\_to\_f}}}{\emph{\DUrole{n}{q}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{f0}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
converts q (srsf) to a function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} vector of size N samples of srsf

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing time sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f0}} \textendash{} initial value

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return f}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_progress() (in module utility\_functions)@\spxentry{update\_progress()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.update_progress}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{update\_progress}}}{\emph{\DUrole{n}{progress}}}{}
This function creates a progress bar
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{progress}} \textendash{} fraction of progress

\end{description}\end{quote}

\end{fulllineitems}

\index{warp\_f\_gamma() (in module utility\_functions)@\spxentry{warp\_f\_gamma()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.warp_f_gamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{warp\_f\_gamma}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{f}}, \emph{\DUrole{n}{gam}}}{}
warps a function f by gam

:param time vector describing time samples
:param q vector describing srsf
:param gam vector describing warping function
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return f\_temp}] \leavevmode
warped srsf

\end{description}\end{quote}

\end{fulllineitems}

\index{warp\_q\_gamma() (in module utility\_functions)@\spxentry{warp\_q\_gamma()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.warp_q_gamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{warp\_q\_gamma}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{q}}, \emph{\DUrole{n}{gam}}}{}
warps a srsf q by gam

:param time vector describing time samples
:param q vector describing srsf
:param gam vector describing warping function
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return q\_temp}] \leavevmode
warped srsf

\end{description}\end{quote}

\end{fulllineitems}

\index{zero\_crossing() (in module utility\_functions)@\spxentry{zero\_crossing()}\spxextra{in module utility\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utility_functions:utility_functions.zero_crossing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utility\_functions.}}\sphinxbfcode{\sphinxupquote{zero\_crossing}}}{\emph{\DUrole{n}{Y}}, \emph{\DUrole{n}{q}}, \emph{\DUrole{n}{bt}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{y\_max}}, \emph{\DUrole{n}{y\_min}}, \emph{\DUrole{n}{gmax}}, \emph{\DUrole{n}{gmin}}}{}
finds zero\sphinxhyphen{}crossing of optimal gamma, gam = s*gmax + (1\sphinxhyphen{}s)*gmin
from elastic regression model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Y}} \textendash{} response

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} predicitve function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bt}} \textendash{} basis function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} time samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_max}} \textendash{} maximum repsonse for warping function gmax

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_min}} \textendash{} minimum response for warping function gmin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gmax}} \textendash{} max warping function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gmin}} \textendash{} min warping fucntion

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return gamma}] \leavevmode
optimal warping function

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Curve Functions}
\label{\detokenize{curve_functions:module-curve_functions}}\label{\detokenize{curve_functions:curve-functions}}\label{\detokenize{curve_functions::doc}}\index{module@\spxentry{module}!curve\_functions@\spxentry{curve\_functions}}\index{curve\_functions@\spxentry{curve\_functions}!module@\spxentry{module}}
functions for SRVF curve manipulations

moduleauthor:: J. Derek Tucker \textless{}\sphinxhref{mailto:jdtuck@sandia.gov}{jdtuck@sandia.gov}\textgreater{}
\index{Basis\_Normal\_A() (in module curve\_functions)@\spxentry{Basis\_Normal\_A()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.Basis_Normal_A}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{Basis\_Normal\_A}}}{\emph{\DUrole{n}{q}}}{}
Find Normal Basis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray (n,T) defining T points on n dimensional SRVF

\end{description}\end{quote}

:rtype list
:return delg: basis

\end{fulllineitems}

\index{calc\_j() (in module curve\_functions)@\spxentry{calc\_j()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.calc_j}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{calc\_j}}}{\emph{\DUrole{n}{basis}}}{}
Calculates Jacobian matrix from normal basis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{basis}} \textendash{} list of numpy ndarray of shape (2,M) of M samples basis

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return j}] \leavevmode
Jacobian

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_variance() (in module curve\_functions)@\spxentry{calculate\_variance()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.calculate_variance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{calculate\_variance}}}{\emph{\DUrole{n}{beta}}}{}
This function calculates variance of curve beta
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return variance}] \leavevmode
variance

\end{description}\end{quote}

\end{fulllineitems}

\index{calculatecentroid() (in module curve\_functions)@\spxentry{calculatecentroid()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.calculatecentroid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{calculatecentroid}}}{\emph{\DUrole{n}{beta}}}{}
This function calculates centroid of a parameterized curve
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return centroid}] \leavevmode
center coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{curve\_to\_q() (in module curve\_functions)@\spxentry{curve\_to\_q()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.curve_to_q}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{curve\_to\_q}}}{\emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{scale}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}O\textquotesingle{}}}}{}
This function converts curve beta to srvf q
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} scale curve to length 1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} \textendash{} Open (‘O’) or closed curve (‘C’) (default ‘O’)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return q}] \leavevmode
srvf of curve

\item[{Return len}] \leavevmode
length of curve

\end{description}\end{quote}

\end{fulllineitems}

\index{curve\_zero\_crossing() (in module curve\_functions)@\spxentry{curve\_zero\_crossing()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.curve_zero_crossing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{curve\_zero\_crossing}}}{\emph{\DUrole{n}{Y}}, \emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{bt}}, \emph{\DUrole{n}{y\_max}}, \emph{\DUrole{n}{y\_min}}, \emph{\DUrole{n}{gmax}}, \emph{\DUrole{n}{gmin}}}{}
finds zero\sphinxhyphen{}crossing of optimal gamma, gam = s*gmax + (1\sphinxhyphen{}s)*gmin
from elastic curve regression model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Y}} \textendash{} response

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} predicitve function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bt}} \textendash{} basis function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_max}} \textendash{} maximum repsonse for warping function gmax

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_min}} \textendash{} minimum response for warping function gmin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gmax}} \textendash{} max warping function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gmin}} \textendash{} min warping fucntion

\end{itemize}

\item[{Return type}] \leavevmode
numpy array

\item[{Return gamma}] \leavevmode
optimal warping function

\item[{Return O\_hat}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{elastic\_distance\_curve() (in module curve\_functions)@\spxentry{elastic\_distance\_curve()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.elastic_distance_curve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{elastic\_distance\_curve}}}{\emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta2}}}{}
Calculates the two elastic distances between two curves
:param beta1: numpy ndarray of shape (2,M) of M samples
:param beta2: numpy ndarray of shape (2,M) of M samples
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
scalar

\item[{Return dist}] \leavevmode
distance

\end{description}\end{quote}

\end{fulllineitems}

\index{elastic\_shooting() (in module curve\_functions)@\spxentry{elastic\_shooting()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.elastic_shooting}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{elastic\_shooting}}}{\emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{v}}}{}
Calculates shooting vector from v to q1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} vector of srvf

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{v}} \textendash{} shooting vector

\end{itemize}

\end{description}\end{quote}

:rtype numpy ndarray
:return q2n: vector of srvf

\end{fulllineitems}

\index{find\_basis\_normal() (in module curve\_functions)@\spxentry{find\_basis\_normal()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.find_basis_normal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{find\_basis\_normal}}}{\emph{\DUrole{n}{q}}}{}
Finds the basis normal to the srvf
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
list of numpy ndarray

\item[{Return basis}] \leavevmode
list containing basis vectors

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_best\_rotation() (in module curve\_functions)@\spxentry{find\_best\_rotation()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.find_best_rotation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{find\_best\_rotation}}}{\emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}}{}
This function calculates the best rotation between two srvfs using
procustes rigid alignment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return q2new}] \leavevmode
optimal rotated q2 to q1

\item[{Return R}] \leavevmode
rotation matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_rotation\_and\_seed\_coord() (in module curve\_functions)@\spxentry{find\_rotation\_and\_seed\_coord()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.find_rotation_and_seed_coord}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{find\_rotation\_and\_seed\_coord}}}{\emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta2}}}{}
This function returns a candidate list of optimally oriented and
registered (seed) shapes w.r.t. beta1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return beta2new}] \leavevmode
optimal rotated beta2 to beta1

\item[{Return O}] \leavevmode
rotation matrix

\item[{Return tau}] \leavevmode
seed

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_rotation\_and\_seed\_q() (in module curve\_functions)@\spxentry{find\_rotation\_and\_seed\_q()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.find_rotation_and_seed_q}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{find\_rotation\_and\_seed\_q}}}{\emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}}{}
This function returns a candidate list of optimally oriented and
registered (seed) shapes w.r.t. beta1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return beta2new}] \leavevmode
optimal rotated beta2 to beta1

\item[{Return O}] \leavevmode
rotation matrix

\item[{Return tau}] \leavevmode
seed

\end{description}\end{quote}

\end{fulllineitems}

\index{gram\_schmidt() (in module curve\_functions)@\spxentry{gram\_schmidt()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.gram_schmidt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{gram\_schmidt}}}{\emph{\DUrole{n}{basis}}}{}
Performs Gram Schmidt Orthogonlization of a basis\_o
\begin{quote}
\begin{quote}\begin{description}
\item[{param basis}] \leavevmode
list of numpy ndarray of shape (2,M) of M samples

\item[{rtype}] \leavevmode
list of numpy ndarray

\item[{return basis\_o}] \leavevmode
orthogonlized basis

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}

\index{group\_action\_by\_gamma() (in module curve\_functions)@\spxentry{group\_action\_by\_gamma()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.group_action_by_gamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{group\_action\_by\_gamma}}}{\emph{\DUrole{n}{q}}, \emph{\DUrole{n}{gamma}}}{}
This function reparamerized srvf q by gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return qn}] \leavevmode
reparatermized srvf

\end{description}\end{quote}

\end{fulllineitems}

\index{group\_action\_by\_gamma\_coord() (in module curve\_functions)@\spxentry{group\_action\_by\_gamma\_coord()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.group_action_by_gamma_coord}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{group\_action\_by\_gamma\_coord}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{gamma}}}{}
This function reparamerized curve f by gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return fn}] \leavevmode
reparatermized curve

\end{description}\end{quote}

\end{fulllineitems}

\index{innerprod\_q2() (in module curve\_functions)@\spxentry{innerprod\_q2()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.innerprod_q2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{innerprod\_q2}}}{\emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}}{}
This function calculates the inner product in srvf space
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return val}] \leavevmode
inner product

\end{description}\end{quote}

\end{fulllineitems}

\index{inverse\_exp() (in module curve\_functions)@\spxentry{inverse\_exp()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.inverse_exp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{inverse\_exp}}}{\emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}, \emph{\DUrole{n}{beta2}}}{}
Calculate the inverse exponential to obtain a shooting vector from
q1 to q2 in shape space of open curves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return v}] \leavevmode
shooting vectors

\end{description}\end{quote}

\end{fulllineitems}

\index{inverse\_exp\_coord() (in module curve\_functions)@\spxentry{inverse\_exp\_coord()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.inverse_exp_coord}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{inverse\_exp\_coord}}}{\emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta2}}}{}
Calculate the inverse exponential to obtain a shooting vector from
beta1 to beta2 in shape space of open curves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return v}] \leavevmode
shooting vectors

\item[{Return dist}] \leavevmode
distance

\end{description}\end{quote}

\end{fulllineitems}

\index{optimum\_reparam\_curve() (in module curve\_functions)@\spxentry{optimum\_reparam\_curve()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.optimum_reparam_curve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{optimum\_reparam\_curve}}}{\emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}, \emph{\DUrole{n}{lam}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
calculates the warping to align srsf q2 to q1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} matrix of size nxN or array of NxM samples of first SRVF

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} \textendash{} vector of size N describing the sample points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} matrix of size nxN or array of NxM samples samples of second SRVF

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} \textendash{} controls the amount of elasticity (default = 0.0)

\end{itemize}

\item[{Return type}] \leavevmode
vector

\item[{Return gam}] \leavevmode
describing the warping function used to align q2 with q1

\end{description}\end{quote}

\end{fulllineitems}

\index{parallel\_translate() (in module curve\_functions)@\spxentry{parallel\_translate()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.parallel_translate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{parallel\_translate}}}{\emph{\DUrole{n}{w}}, \emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
parallel translates q1 and q2 along manifold
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{w}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basis}} \textendash{} list of numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} \textendash{} open 0 or closed curves 1 (default 0)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return wbar}] \leavevmode
translated vector

\end{description}\end{quote}

\end{fulllineitems}

\index{pre\_proc\_curve() (in module curve\_functions)@\spxentry{pre\_proc\_curve()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.pre_proc_curve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{pre\_proc\_curve}}}{\emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{T}\DUrole{o}{=}\DUrole{default_value}{100}}}{}
This function prepcoessed a curve beta to set of closed curves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} \textendash{} number of samples (default = 100)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return betanew}] \leavevmode
projected beta

\item[{Return qnew}] \leavevmode
projected srvf

\item[{Return A}] \leavevmode
alignment matrix (not used currently)

\end{description}\end{quote}

\end{fulllineitems}

\index{project\_curve() (in module curve\_functions)@\spxentry{project\_curve()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.project_curve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{project\_curve}}}{\emph{\DUrole{n}{q}}}{}
This function projects srvf q to set of close curves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return qproj}] \leavevmode
project srvf

\end{description}\end{quote}

\end{fulllineitems}

\index{project\_tangent() (in module curve\_functions)@\spxentry{project\_tangent()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.project_tangent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{project\_tangent}}}{\emph{\DUrole{n}{w}}, \emph{\DUrole{n}{q}}, \emph{\DUrole{n}{basis}}}{}
projects srvf to tangent space w using basis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{w}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basis}} \textendash{} list of numpy ndarray of shape (2,M) of M samples

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return wproj}] \leavevmode
projected q

\end{description}\end{quote}

\end{fulllineitems}

\index{psi() (in module curve\_functions)@\spxentry{psi()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.psi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{psi}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{q}}}{}
This function formats variance output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} numpy ndarray of shape (2,M) of M samples curve

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a}} \textendash{} numpy ndarray of shape (2,1) mean

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray of shape (2,M) of M samples srvf

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return psi1}] \leavevmode
variance

\item[{Return psi2}] \leavevmode
cross variance

\item[{Return psi3}] \leavevmode
curve end

\item[{Return psi4}] \leavevmode
curve end

\end{description}\end{quote}

\end{fulllineitems}

\index{q\_to\_curve() (in module curve\_functions)@\spxentry{q\_to\_curve()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.q_to_curve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{q\_to\_curve}}}{\emph{\DUrole{n}{q}}, \emph{\DUrole{n}{scale}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
This function converts srvf to beta
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q}} \textendash{} numpy ndarray of shape (n,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} scale of curve

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return beta}] \leavevmode
parameterized curve

\end{description}\end{quote}

\end{fulllineitems}

\index{resamplecurve() (in module curve\_functions)@\spxentry{resamplecurve()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.resamplecurve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{resamplecurve}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{N}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}O\textquotesingle{}}}}{}
This function resamples a curve to have N samples
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{N}} \textendash{} Number of samples for new curve (default = 100)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} \textendash{} Open (‘O’) or closed curve (‘C’) (default ‘O’)

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return xn}] \leavevmode
resampled curve

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_curve() (in module curve\_functions)@\spxentry{scale\_curve()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.scale_curve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{scale\_curve}}}{\emph{\DUrole{n}{beta}}}{}
scales curve to length 1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{beta}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return beta\_scaled}] \leavevmode
scaled curve

\item[{Return scale}] \leavevmode
scale factor used

\end{description}\end{quote}

\end{fulllineitems}

\index{shift\_f() (in module curve\_functions)@\spxentry{shift\_f()}\spxextra{in module curve\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{curve_functions:curve_functions.shift_f}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{curve\_functions.}}\sphinxbfcode{\sphinxupquote{shift\_f}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{tau}}}{}
shifts a curve f by tau
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} numpy ndarray of shape (2,M) of M samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau}} \textendash{} scalar

\end{itemize}

\item[{Return type}] \leavevmode
numpy ndarray

\item[{Return fn}] \leavevmode
shifted curve

\end{description}\end{quote}

\end{fulllineitems}



\chapter{UMAP EFDA Metrics}
\label{\detokenize{umap_metric:module-umap_metric}}\label{\detokenize{umap_metric:umap-efda-metrics}}\label{\detokenize{umap_metric::doc}}\index{module@\spxentry{module}!umap\_metric@\spxentry{umap\_metric}}\index{umap\_metric@\spxentry{umap\_metric}!module@\spxentry{module}}\index{efda\_distance() (in module umap\_metric)@\spxentry{efda\_distance()}\spxextra{in module umap\_metric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{umap_metric:umap_metric.efda_distance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{umap\_metric.}}\sphinxbfcode{\sphinxupquote{efda\_distance}}}{\emph{\DUrole{n}{q1}}, \emph{\DUrole{n}{q2}}}{}
”
calculates the distances between two curves, where 
q2 is aligned to q1. In other words calculates the elastic distances/
This metric is set up for use with UMAP or t\sphinxhyphen{}sne from scikit\sphinxhyphen{}learn
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q1}} \textendash{} vector of size N

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{q2}} \textendash{} vector of size N

\end{itemize}

\item[{Return type}] \leavevmode
scalar

\item[{Return dist}] \leavevmode
amplitude distance

\end{description}\end{quote}

\end{fulllineitems}

\index{efda\_distance\_curve() (in module umap\_metric)@\spxentry{efda\_distance\_curve()}\spxextra{in module umap\_metric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{umap_metric:umap_metric.efda_distance_curve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{umap\_metric.}}\sphinxbfcode{\sphinxupquote{efda\_distance\_curve}}}{\emph{\DUrole{n}{beta1}}, \emph{\DUrole{n}{beta2}}}{}
”
calculates the distances between two curves, where 
beta2 is aligned to beta1. In other words calculates the elastic distance.
This metric is set up for use with UMAP or t\sphinxhyphen{}sne from scikit\sphinxhyphen{}learn
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta1}} \textendash{} vector of size n*M

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta2}} \textendash{} vector of size n*M

\end{itemize}

\item[{Return type}] \leavevmode
scalar

\item[{Return dist}] \leavevmode
shape distance

\end{description}\end{quote}

\end{fulllineitems}



\chapter{References}
\label{\detokenize{index:references}}\begin{quote}

Tucker, J. D. 2014, Functional Component Analysis and Regression using Elastic
Methods. Ph.D. Thesis, Florida State University.

Robinson, D. T. 2012, Function Data Analysis and Partial Shape Matching in the
Square Root Velocity Framework. Ph.D. Thesis, Florida State University.

Huang, W. 2014, Optimization Algorithms on Riemannian Manifolds with
Applications. Ph.D. Thesis, Florida State University.

Srivastava, A., Wu, W., Kurtek, S., Klassen, E. and Marron, J. S. (2011).
Registration of Functional Data Using Fisher\sphinxhyphen{}Rao Metric. arXiv:1103.3817v2
{[}math.ST{]}.

Tucker, J. D., Wu, W. and Srivastava, A. (2013). Generative models for
functional data using phase and amplitude separation. Computational Statistics
and Data Analysis 61, 50\sphinxhyphen{}66.

J. D. Tucker, W. Wu, and A. Srivastava, “Phase\sphinxhyphen{}Amplitude Separation of
Proteomics Data Using Extended Fisher\sphinxhyphen{}Rao Metric,” Electronic Journal of
Statistics, Vol 8, no. 2. pp 1724\sphinxhyphen{}1733, 2014.

J. D. Tucker, W. Wu, and A. Srivastava, “Analysis of signals under compositional
noise With applications to SONAR data,” IEEE Journal of Oceanic Engineering, Vol
29, no. 2. pp 318\sphinxhyphen{}330, Apr 2014.

Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of
elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence,
IEEE Transactions on 33 (7), 1415\sphinxhyphen{}1428.

S. Kurtek, A. Srivastava, and W. Wu. Signal estimation under random
time\sphinxhyphen{}warpings and nonlinear signal alignment. In Proceedings of Neural
Information Processing Systems (NIPS), 2011.

Wen Huang, Kyle A. Gallivan, Anuj Srivastava, Pierre\sphinxhyphen{}Antoine Absil. “Riemannian
Optimization for Elastic Shape Analysis”, Short version, The 21st International
Symposium on Mathematical Theory of Networks and Systems (MTNS 2014).

Cheng, W., Dryden, I. L., and Huang, X. (2016). Bayesian registration of functions
and curves. Bayesian Analysis, 11(2), 447\sphinxhyphen{}475.

W. Xie, S. Kurtek, K. Bharath, and Y. Sun, A geometric approach to visualization
of variability in functional data, Journal of American Statistical Association 112
(2017), pp. 979\sphinxhyphen{}993.

Lu, Y., R. Herbei, and S. Kurtek, 2017: Bayesian registration of functions with a Gaussian process prior. Journal of
Computational and Graphical Statistics, 26, no. 4, 894\textendash{}904.

Lee, S. and S. Jung, 2017: Combined analysis of amplitude and phase variations in functional data. arXiv:1603.01775 {[}stat.ME{]}, 1\textendash{}21.
\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{9}
\item {} \begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumii}{enumiii}{}{.}%
\setcounter{enumii}{3}
\item {} 
Tucker, J. R. Lewis, and A. Srivastava, “Elastic Functional Principal Component Regression,” Statistical Analysis and Data Mining, vol. 12, no. 2, pp. 101\sphinxhyphen{}115, 2019.

\end{enumerate}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{9}
\item {} \begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumii}{enumiii}{}{.}%
\setcounter{enumii}{3}
\item {} 
Tucker, J. R. Lewis, C. King, and S. Kurtek, “A Geometric Approach for Computing Tolerance Bounds for Elastic Functional Data,” Journal of Applied Statistics, 10.1080/02664763.2019.1645818, 2019.

\end{enumerate}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{19}
\item {} 
Harris, J. D. Tucker, B. Li, and L. Shand, “Elastic depths for detecting shape anomalies in functional data,” Technometrics, 10.1080/00401706.2020.1811156, 2020.

\end{enumerate}
\end{quote}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{b}
\item\relax\sphinxstyleindexentry{boxplots}\sphinxstyleindexpageref{boxplots:\detokenize{module-boxplots}}
\indexspace
\bigletter{c}
\item\relax\sphinxstyleindexentry{curve\_functions}\sphinxstyleindexpageref{curve_functions:\detokenize{module-curve_functions}}
\item\relax\sphinxstyleindexentry{curve\_stats}\sphinxstyleindexpageref{curve_statistics:\detokenize{module-curve_stats}}
\indexspace
\bigletter{f}
\item\relax\sphinxstyleindexentry{fPCA}\sphinxstyleindexpageref{fPCA:\detokenize{module-fPCA}}
\item\relax\sphinxstyleindexentry{fPLS}\sphinxstyleindexpageref{fPLS:\detokenize{module-fPLS}}
\indexspace
\bigletter{g}
\item\relax\sphinxstyleindexentry{geodesic}\sphinxstyleindexpageref{geodesic:\detokenize{module-geodesic}}
\indexspace
\bigletter{p}
\item\relax\sphinxstyleindexentry{pcr\_regression}\sphinxstyleindexpageref{pcr_regression:\detokenize{module-pcr_regression}}
\indexspace
\bigletter{r}
\item\relax\sphinxstyleindexentry{regression}\sphinxstyleindexpageref{regression:\detokenize{module-regression}}
\indexspace
\bigletter{t}
\item\relax\sphinxstyleindexentry{time\_warping}\sphinxstyleindexpageref{time_warping:\detokenize{module-time_warping}}
\item\relax\sphinxstyleindexentry{tolerance}\sphinxstyleindexpageref{tolerance:\detokenize{module-tolerance}}
\indexspace
\bigletter{u}
\item\relax\sphinxstyleindexentry{umap\_metric}\sphinxstyleindexpageref{umap_metric:\detokenize{module-umap_metric}}
\item\relax\sphinxstyleindexentry{utility\_functions}\sphinxstyleindexpageref{utility_functions:\detokenize{module-utility_functions}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}